{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../../Source/Core/GeographicTilingScheme.js","../../../../Source/Core/ApproximateTerrainHeights.js","../../../../Source/Core/GroundPolylineGeometry.js","../../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from './Cartesian2.js';\nimport Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport GeographicProjection from './GeographicProjection.js';\nimport CesiumMath from './Math.js';\nimport Rectangle from './Rectangle.js';\n\n    /**\n     * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n     * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n     * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\n     *\n     * @alias GeographicTilingScheme\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\n     * the WGS84 ellipsoid.\n     * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n     * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n     * the tile tree.\n     * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n     * the tile tree.\n     */\n    function GeographicTilingScheme(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n        this._projection = new GeographicProjection(this._ellipsoid);\n        this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);\n        this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);\n    }\n\n    Object.defineProperties(GeographicTilingScheme.prototype, {\n        /**\n         * Gets the ellipsoid that is tiled by this tiling scheme.\n         * @memberof GeographicTilingScheme.prototype\n         * @type {Ellipsoid}\n         */\n        ellipsoid : {\n            get : function() {\n                return this._ellipsoid;\n            }\n        },\n\n        /**\n         * Gets the rectangle, in radians, covered by this tiling scheme.\n         * @memberof GeographicTilingScheme.prototype\n         * @type {Rectangle}\n         */\n        rectangle : {\n            get : function() {\n                return this._rectangle;\n            }\n        },\n\n        /**\n         * Gets the map projection used by this tiling scheme.\n         * @memberof GeographicTilingScheme.prototype\n         * @type {MapProjection}\n         */\n        projection : {\n            get : function() {\n                return this._projection;\n            }\n        }\n    });\n\n    /**\n     * Gets the total number of tiles in the X direction at a specified level-of-detail.\n     *\n     * @param {Number} level The level-of-detail.\n     * @returns {Number} The number of tiles in the X direction at the given level.\n     */\n    GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {\n        return this._numberOfLevelZeroTilesX << level;\n    };\n\n    /**\n     * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n     *\n     * @param {Number} level The level-of-detail.\n     * @returns {Number} The number of tiles in the Y direction at the given level.\n     */\n    GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {\n        return this._numberOfLevelZeroTilesY << level;\n    };\n\n    /**\n     * Transforms a rectangle specified in geodetic radians to the native coordinate system\n     * of this tiling scheme.\n     *\n     * @param {Rectangle} rectangle The rectangle to transform.\n     * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n     *        should be created.\n     * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n     *          is undefined.\n     */\n    GeographicTilingScheme.prototype.rectangleToNativeRectangle = function(rectangle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('rectangle', rectangle);\n        //>>includeEnd('debug');\n\n        var west = CesiumMath.toDegrees(rectangle.west);\n        var south = CesiumMath.toDegrees(rectangle.south);\n        var east = CesiumMath.toDegrees(rectangle.east);\n        var north = CesiumMath.toDegrees(rectangle.north);\n\n        if (!defined(result)) {\n            return new Rectangle(west, south, east, north);\n        }\n\n        result.west = west;\n        result.south = south;\n        result.east = east;\n        result.north = north;\n        return result;\n    };\n\n    /**\n     * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n     * of the tiling scheme.\n     *\n     * @param {Number} x The integer x coordinate of the tile.\n     * @param {Number} y The integer y coordinate of the tile.\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n     *        should be created.\n     * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n     *          if 'result' is undefined.\n     */\n    GeographicTilingScheme.prototype.tileXYToNativeRectangle = function(x, y, level, result) {\n        var rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n        rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n        rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n        rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n        rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n        return rectangleRadians;\n    };\n\n    /**\n     * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n     *\n     * @param {Number} x The integer x coordinate of the tile.\n     * @param {Number} y The integer y coordinate of the tile.\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n     *        should be created.\n     * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n     *          if 'result' is undefined.\n     */\n    GeographicTilingScheme.prototype.tileXYToRectangle = function(x, y, level, result) {\n        var rectangle = this._rectangle;\n\n        var xTiles = this.getNumberOfXTilesAtLevel(level);\n        var yTiles = this.getNumberOfYTilesAtLevel(level);\n\n        var xTileWidth = rectangle.width / xTiles;\n        var west = x * xTileWidth + rectangle.west;\n        var east = (x + 1) * xTileWidth + rectangle.west;\n\n        var yTileHeight = rectangle.height / yTiles;\n        var north = rectangle.north - y * yTileHeight;\n        var south = rectangle.north - (y + 1) * yTileHeight;\n\n        if (!defined(result)) {\n            result = new Rectangle(west, south, east, north);\n        }\n\n        result.west = west;\n        result.south = south;\n        result.east = east;\n        result.north = north;\n        return result;\n    };\n\n    /**\n     * Calculates the tile x, y coordinates of the tile containing\n     * a given cartographic position.\n     *\n     * @param {Cartographic} position The position.\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n     * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n     *        should be created.\n     * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n     *          if 'result' is undefined.\n     */\n    GeographicTilingScheme.prototype.positionToTileXY = function(position, level, result) {\n        var rectangle = this._rectangle;\n        if (!Rectangle.contains(rectangle, position)) {\n            // outside the bounds of the tiling scheme\n            return undefined;\n        }\n\n        var xTiles = this.getNumberOfXTilesAtLevel(level);\n        var yTiles = this.getNumberOfYTilesAtLevel(level);\n\n        var xTileWidth = rectangle.width / xTiles;\n        var yTileHeight = rectangle.height / yTiles;\n\n        var longitude = position.longitude;\n        if (rectangle.east < rectangle.west) {\n            longitude += CesiumMath.TWO_PI;\n        }\n\n        var xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;\n        if (xTileCoordinate >= xTiles) {\n            xTileCoordinate = xTiles - 1;\n        }\n\n        var yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;\n        if (yTileCoordinate >= yTiles) {\n            yTileCoordinate = yTiles - 1;\n        }\n\n        if (!defined(result)) {\n            return new Cartesian2(xTileCoordinate, yTileCoordinate);\n        }\n\n        result.x = xTileCoordinate;\n        result.y = yTileCoordinate;\n        return result;\n    };\nexport default GeographicTilingScheme;\n","import BoundingSphere from './BoundingSphere.js';\nimport buildModuleUrl from './buildModuleUrl.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport GeographicTilingScheme from './GeographicTilingScheme.js';\nimport Rectangle from './Rectangle.js';\nimport Resource from './Resource.js';\n\n    var scratchDiagonalCartesianNE = new Cartesian3();\n    var scratchDiagonalCartesianSW = new Cartesian3();\n    var scratchDiagonalCartographic = new Cartographic();\n    var scratchCenterCartesian = new Cartesian3();\n    var scratchSurfaceCartesian = new Cartesian3();\n\n    var scratchBoundingSphere = new BoundingSphere();\n    var tilingScheme = new GeographicTilingScheme();\n    var scratchCorners = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\n    var scratchTileXY = new Cartesian2();\n\n    /**\n     * A collection of functions for approximating terrain height\n     * @private\n     */\n    var ApproximateTerrainHeights = {};\n\n    /**\n     * Initializes the minimum and maximum terrain heights\n     * @return {Promise}\n     */\n    ApproximateTerrainHeights.initialize = function() {\n        var initPromise = ApproximateTerrainHeights._initPromise;\n        if (defined(initPromise)) {\n            return initPromise;\n        }\n\n        initPromise = Resource.fetchJson(buildModuleUrl('Assets/approximateTerrainHeights.json'))\n            .then(function(json) {\n                ApproximateTerrainHeights._terrainHeights = json;\n            });\n        ApproximateTerrainHeights._initPromise = initPromise;\n\n        return initPromise;\n    };\n\n    /**\n     * Computes the minimum and maximum terrain heights for a given rectangle\n     * @param {Rectangle} rectangle The bounding rectangle\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n     * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\n     */\n    ApproximateTerrainHeights.getMinimumMaximumHeights = function(rectangle, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('rectangle', rectangle);\n        if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n            throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\n        }\n        //>>includeEnd('debug');\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n        var xyLevel = getTileXYLevel(rectangle);\n\n        // Get the terrain min/max for that tile\n        var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n        var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n        if (defined(xyLevel)) {\n            var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\n            var heights = ApproximateTerrainHeights._terrainHeights[key];\n            if (defined(heights)) {\n                minTerrainHeight = heights[0];\n                maxTerrainHeight = heights[1];\n            }\n\n            // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n            ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle, scratchDiagonalCartographic),\n                scratchDiagonalCartesianNE);\n            ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle, scratchDiagonalCartographic),\n                scratchDiagonalCartesianSW);\n\n            Cartesian3.midpoint(scratchDiagonalCartesianSW, scratchDiagonalCartesianNE, scratchCenterCartesian);\n            var surfacePosition = ellipsoid.scaleToGeodeticSurface(scratchCenterCartesian, scratchSurfaceCartesian);\n            if (defined(surfacePosition)) {\n                var distance = Cartesian3.distance(scratchCenterCartesian, surfacePosition);\n                minTerrainHeight = Math.min(minTerrainHeight, -distance);\n            } else {\n                minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n            }\n        }\n\n        minTerrainHeight = Math.max(ApproximateTerrainHeights._defaultMinTerrainHeight, minTerrainHeight);\n\n        return {\n            minimumTerrainHeight: minTerrainHeight,\n            maximumTerrainHeight: maxTerrainHeight\n        };\n    };\n\n    /**\n     * Computes the bounding sphere based on the tile heights in the rectangle\n     * @param {Rectangle} rectangle The bounding rectangle\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n     * @return {BoundingSphere} The result bounding sphere\n     */\n    ApproximateTerrainHeights.getBoundingSphere = function(rectangle, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('rectangle', rectangle);\n        if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n            throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\n        }\n        //>>includeEnd('debug');\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n        var xyLevel = getTileXYLevel(rectangle);\n\n        // Get the terrain max for that tile\n        var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n        if (defined(xyLevel)) {\n            var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\n            var heights = ApproximateTerrainHeights._terrainHeights[key];\n            if (defined(heights)) {\n                maxTerrainHeight = heights[1];\n            }\n        }\n\n        var result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n        BoundingSphere.fromRectangle3D(rectangle, ellipsoid, maxTerrainHeight, scratchBoundingSphere);\n\n        return BoundingSphere.union(result, scratchBoundingSphere, result);\n    };\n\n    function getTileXYLevel(rectangle) {\n        Cartographic.fromRadians(rectangle.east, rectangle.north, 0.0, scratchCorners[0]);\n        Cartographic.fromRadians(rectangle.west, rectangle.north, 0.0, scratchCorners[1]);\n        Cartographic.fromRadians(rectangle.east, rectangle.south, 0.0, scratchCorners[2]);\n        Cartographic.fromRadians(rectangle.west, rectangle.south, 0.0, scratchCorners[3]);\n\n        // Determine which tile the bounding rectangle is in\n        var lastLevelX = 0, lastLevelY = 0;\n        var currentX = 0, currentY = 0;\n        var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n        var i;\n        for(i = 0; i <= maxLevel; ++i) {\n            var failed = false;\n            for(var j = 0; j < 4; ++j) {\n                var corner = scratchCorners[j];\n                tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n                if (j === 0) {\n                    currentX = scratchTileXY.x;\n                    currentY = scratchTileXY.y;\n                } else if(currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n                    failed = true;\n                    break;\n                }\n            }\n\n            if (failed) {\n                break;\n            }\n\n            lastLevelX = currentX;\n            lastLevelY = currentY;\n        }\n\n        if (i === 0) {\n            return undefined;\n        }\n\n        return {\n            x : lastLevelX,\n            y : lastLevelY,\n            level : (i > maxLevel) ? maxLevel : (i - 1)\n        };\n    }\n\n    ApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\n    ApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\n    ApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\n    ApproximateTerrainHeights._terrainHeights = undefined;\n    ApproximateTerrainHeights._initPromise = undefined;\n\n    Object.defineProperties(ApproximateTerrainHeights, {\n        /**\n         * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n         * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n         * @type {Boolean}\n         * @readonly\n         * @memberof ApproximateTerrainHeights\n         */\n        initialized: {\n            get: function() {\n                return defined(ApproximateTerrainHeights._terrainHeights);\n            }\n        }\n    });\nexport default ApproximateTerrainHeights;\n","import ApproximateTerrainHeights from './ApproximateTerrainHeights.js';\nimport ArcType from './ArcType.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\nimport EncodedCartesian3 from './EncodedCartesian3.js';\nimport GeographicProjection from './GeographicProjection.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport IntersectionTests from './IntersectionTests.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Plane from './Plane.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport WebMercatorProjection from './WebMercatorProjection.js';\n\n    var PROJECTIONS = [GeographicProjection, WebMercatorProjection];\n    var PROJECTION_COUNT = PROJECTIONS.length;\n\n    var MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\n    var MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n    // Initial heights for constructing the wall.\n    // Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n    // prevent precision problems with planes in the shader.\n    // Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n    // which is a highly conservative bound, usually puts the plane origin several thousands\n    // of meters away from the actual terrain, causing floating point problems when checking\n    // fragments on terrain against the plane.\n    // Ellipsoid height is generally much closer.\n    // The initial max height is arbitrary.\n    // Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\n    var WALL_INITIAL_MIN_HEIGHT = 0.0;\n    var WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n    /**\n     * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n     *\n     * @alias GroundPolylineGeometry\n     * @constructor\n     *\n     * @param {Object} options Options with the following properties:\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n     * @param {Number} [options.width=1.0] The screen space width in pixels.\n     * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n     * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @exception {DeveloperError} At least two positions are required.\n     *\n     * @see GroundPolylinePrimitive\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -112.1340164450331, 36.05494287836128,\n     *   -112.08821010582645, 36.097804071380715,\n     *   -112.13296079730024, 36.168769146801104\n     * ]);\n     *\n     * var geometry = new Cesium.GroundPolylineGeometry({\n     *   positions : positions\n     * });\n     */\n    function GroundPolylineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        //>>includeStart('debug', pragmas.debug);\n        if ((!defined(positions)) || (positions.length < 2)) {\n            throw new DeveloperError('At least two positions are required.');\n        }\n        if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\n            throw new DeveloperError('Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.');\n        }\n        //>>includeEnd('debug');\n\n        /**\n         * The screen space width in pixels.\n         * @type {Number}\n         */\n        this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n        this._positions = positions;\n\n        /**\n         * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n         * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n         * @type {Boolean}\n         * @default 9999.0\n         */\n        this.granularity = defaultValue(options.granularity, 9999.0);\n\n        /**\n         * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n         * If the geometry has two positions this parameter will be ignored.\n         * @type {Boolean}\n         * @default false\n         */\n        this.loop = defaultValue(options.loop, false);\n\n        /**\n         * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n         * @type {ArcType}\n         * @default ArcType.GEODESIC\n         */\n        this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        this._ellipsoid = Ellipsoid.WGS84;\n\n        // MapProjections can't be packed, so store the index to a known MapProjection.\n        this._projectionIndex = 0;\n        this._workerName = 'createGroundPolylineGeometry';\n\n        // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n        this._scene3DOnly = false;\n    }\n\n    Object.defineProperties(GroundPolylineGeometry.prototype, {\n        /**\n         * The number of elements used to pack the object into an array.\n         * @memberof GroundPolylineGeometry.prototype\n         * @type {Number}\n         * @readonly\n         * @private\n         */\n        packedLength: {\n            get: function() {\n                return 1.0 + this._positions.length * 3 + 1.0 + 1.0 + 1.0 + Ellipsoid.packedLength + 1.0 + 1.0;\n            }\n        }\n    });\n\n    /**\n     * Set the GroundPolylineGeometry's projection and ellipsoid.\n     * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n     *\n     * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n     * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n     * @private\n     */\n    GroundPolylineGeometry.setProjectionAndEllipsoid = function(groundPolylineGeometry, mapProjection) {\n        var projectionIndex = 0;\n        for (var i = 0; i < PROJECTION_COUNT; i++) {\n            if (mapProjection instanceof PROJECTIONS[i]) {\n                projectionIndex = i;\n                break;\n            }\n        }\n\n        groundPolylineGeometry._projectionIndex = projectionIndex;\n        groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n    };\n\n    var cart3Scratch1 = new Cartesian3();\n    var cart3Scratch2 = new Cartesian3();\n    var cart3Scratch3 = new Cartesian3();\n    function computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n        var startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n        var startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n        var endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n\n        var up = direction(startTop, startBottom, cart3Scratch2);\n        var forward = direction(endBottom, startBottom, cart3Scratch3);\n\n        Cartesian3.cross(forward, up, result);\n        return Cartesian3.normalize(result, result);\n    }\n\n    var interpolatedCartographicScratch = new Cartographic();\n    var interpolatedBottomScratch = new Cartesian3();\n    var interpolatedTopScratch = new Cartesian3();\n    var interpolatedNormalScratch = new Cartesian3();\n    function interpolateSegment(start, end, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray) {\n        if (granularity === 0.0) {\n            return;\n        }\n\n        var ellipsoidLine;\n        if (arcType === ArcType.GEODESIC) {\n            ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n        } else if (arcType === ArcType.RHUMB) {\n            ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n        }\n\n        var surfaceDistance = ellipsoidLine.surfaceDistance;\n        if (surfaceDistance < granularity) {\n            return;\n        }\n\n        // Compute rightwards normal applicable at all interpolated points\n        var interpolatedNormal = computeRightNormal(start, end, maxHeight, ellipsoid, interpolatedNormalScratch);\n\n        var segments = Math.ceil(surfaceDistance / granularity);\n        var interpointDistance = surfaceDistance / segments;\n        var distanceFromStart = interpointDistance;\n        var pointsToAdd = segments - 1;\n        var packIndex = normalsArray.length;\n        for (var i = 0; i < pointsToAdd; i++) {\n            var interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(distanceFromStart, interpolatedCartographicScratch);\n            var interpolatedBottom = getPosition(ellipsoid, interpolatedCartographic, minHeight, interpolatedBottomScratch);\n            var interpolatedTop = getPosition(ellipsoid, interpolatedCartographic, maxHeight, interpolatedTopScratch);\n\n            Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n            Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n            Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n            cartographicsArray.push(interpolatedCartographic.latitude);\n            cartographicsArray.push(interpolatedCartographic.longitude);\n\n            packIndex += 3;\n            distanceFromStart += interpointDistance;\n        }\n    }\n\n    var heightlessCartographicScratch = new Cartographic();\n    function getPosition(ellipsoid, cartographic, height, result) {\n        Cartographic.clone(cartographic, heightlessCartographicScratch);\n        heightlessCartographicScratch.height = height;\n        return Cartographic.toCartesian(heightlessCartographicScratch, ellipsoid, result);\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    GroundPolylineGeometry.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('value', value);\n        Check.defined('array', array);\n        //>>includeEnd('debug');\n\n        var index = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var positionsLength = positions.length;\n\n        array[index++] = positionsLength;\n\n        for (var i = 0; i < positionsLength; ++i) {\n            var cartesian = positions[i];\n            Cartesian3.pack(cartesian, array, index);\n            index += 3;\n        }\n\n        array[index++] = value.granularity;\n        array[index++] = value.loop ? 1.0 : 0.0;\n        array[index++] = value.arcType;\n\n        Ellipsoid.pack(value._ellipsoid, array, index);\n        index += Ellipsoid.packedLength;\n\n        array[index++] = value._projectionIndex;\n        array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n\n        return array;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonGeometry} [result] The object into which to store the result.\n     */\n    GroundPolylineGeometry.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('array', array);\n        //>>includeEnd('debug');\n\n        var index = defaultValue(startingIndex, 0);\n        var positionsLength = array[index++];\n        var positions = new Array(positionsLength);\n\n        for (var i = 0; i < positionsLength; i++) {\n            positions[i] = Cartesian3.unpack(array, index);\n            index += 3;\n        }\n\n        var granularity = array[index++];\n        var loop = array[index++] === 1.0;\n        var arcType = array[index++];\n\n        var ellipsoid = Ellipsoid.unpack(array, index);\n        index += Ellipsoid.packedLength;\n\n        var projectionIndex = array[index++];\n        var scene3DOnly = (array[index++] === 1.0);\n\n        if (!defined(result)) {\n            result = new GroundPolylineGeometry({\n                positions : positions\n            });\n        }\n\n        result._positions = positions;\n        result.granularity = granularity;\n        result.loop = loop;\n        result.arcType = arcType;\n        result._ellipsoid = ellipsoid;\n        result._projectionIndex = projectionIndex;\n        result._scene3DOnly = scene3DOnly;\n\n        return result;\n    };\n\n    function direction(target, origin, result) {\n        Cartesian3.subtract(target, origin, result);\n        Cartesian3.normalize(result, result);\n        return result;\n    }\n\n    function tangentDirection(target, origin, up, result) {\n        result = direction(target, origin, result);\n\n        // orthogonalize\n        result = Cartesian3.cross(result, up, result);\n        result = Cartesian3.normalize(result, result);\n        result = Cartesian3.cross(up, result, result);\n        return result;\n    }\n\n    var toPreviousScratch = new Cartesian3();\n    var toNextScratch = new Cartesian3();\n    var forwardScratch = new Cartesian3();\n    var vertexUpScratch = new Cartesian3();\n    var cosine90 = 0.0;\n    var cosine180 = -1.0;\n    function computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, result) {\n        var up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n        // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n        var toPrevious = tangentDirection(previousBottom, vertexBottom, up, toPreviousScratch);\n        var toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n        // Check if tangents are almost opposite - if so, no need to miter.\n        if (CesiumMath.equalsEpsilon(Cartesian3.dot(toPrevious, toNext), cosine180, CesiumMath.EPSILON5)) {\n             result = Cartesian3.cross(up, toPrevious, result);\n             result = Cartesian3.normalize(result, result);\n             return result;\n        }\n\n        // Average directions to previous and to next in the plane of Up\n        result = Cartesian3.add(toNext, toPrevious, result);\n        result = Cartesian3.normalize(result, result);\n\n        // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n        var forward = Cartesian3.cross(up, result, forwardScratch);\n        if (Cartesian3.dot(toNext, forward) < cosine90) {\n            result = Cartesian3.negate(result, result);\n        }\n\n        return result;\n    }\n\n    var XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\n    var previousBottomScratch = new Cartesian3();\n    var vertexBottomScratch = new Cartesian3();\n    var vertexTopScratch = new Cartesian3();\n    var nextBottomScratch = new Cartesian3();\n    var vertexNormalScratch = new Cartesian3();\n    var intersectionScratch = new Cartesian3();\n    var cartographicScratch0 = new Cartographic();\n    var cartographicScratch1 = new Cartographic();\n    var cartographicIntersectionScratch = new Cartographic();\n    /**\n     * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n     * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n     * Should not be called independent of {@link GroundPolylinePrimitive}.\n     *\n     * @param {GroundPolylineGeometry} groundPolylineGeometry\n     * @private\n     */\n    GroundPolylineGeometry.createGeometry = function(groundPolylineGeometry) {\n        var compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n        var loop = groundPolylineGeometry.loop;\n        var ellipsoid = groundPolylineGeometry._ellipsoid;\n        var granularity = groundPolylineGeometry.granularity;\n        var arcType = groundPolylineGeometry.arcType;\n        var projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](ellipsoid);\n\n        var minHeight = WALL_INITIAL_MIN_HEIGHT;\n        var maxHeight = WALL_INITIAL_MAX_HEIGHT;\n\n        var index;\n        var i;\n\n        var positions = groundPolylineGeometry._positions;\n        var positionsLength = positions.length;\n\n        if (positionsLength === 2) {\n            loop = false;\n        }\n\n        // Split positions across the IDL and the Prime Meridian as well.\n        // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n        // may get split by the plane of IDL + Prime Meridian.\n        var p0;\n        var p1;\n        var c0;\n        var c1;\n        var rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n        var intersection;\n        var intersectionCartographic;\n        var intersectionLongitude;\n        var splitPositions = [positions[0]];\n        for (i = 0; i < positionsLength - 1; i++) {\n            p0 = positions[i];\n            p1 = positions[i + 1];\n            intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\n            if (defined(intersection) &&\n                !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n                !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n                if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n                    splitPositions.push(Cartesian3.clone(intersection));\n                } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n                    intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\n                    c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n                    c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n                    rhumbLine.setEndPoints(c0, c1);\n                    intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\n                    intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\n                    if (defined(intersection) &&\n                        !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n                        !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n                        splitPositions.push(Cartesian3.clone(intersection));\n                    }\n                }\n            }\n            splitPositions.push(p1);\n        }\n\n        if (loop) {\n            p0 = positions[positionsLength - 1];\n            p1 = positions[0];\n            intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\n            if (defined(intersection) &&\n                !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n                !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n                if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n                    splitPositions.push(Cartesian3.clone(intersection));\n                } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n                    intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\n                    c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n                    c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n                    rhumbLine.setEndPoints(c0, c1);\n                    intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\n                    intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\n                    if (defined(intersection) &&\n                        !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n                        !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n                        splitPositions.push(Cartesian3.clone(intersection));\n                    }\n                }\n            }\n        }\n        var cartographicsLength = splitPositions.length;\n\n        var cartographics = new Array(cartographicsLength);\n        for (i = 0; i < cartographicsLength; i++) {\n            var cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\n            cartographic.height = 0.0;\n            cartographics[i] = cartographic;\n        }\n\n        cartographics = arrayRemoveDuplicates(cartographics, Cartographic.equalsEpsilon);\n        cartographicsLength = cartographics.length;\n\n        if (cartographicsLength < 2) {\n            return undefined;\n        }\n\n        /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n        // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n        // of information about the wall. Also, this simplifies interpolation.\n        // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n        // and we are computing normals pointing towards the local right side of the vertices in each segment.\n        var cartographicsArray = [];\n        var normalsArray = [];\n        var bottomPositionsArray = [];\n        var topPositionsArray = [];\n\n        var previousBottom = previousBottomScratch;\n        var vertexBottom = vertexBottomScratch;\n        var vertexTop = vertexTopScratch;\n        var nextBottom = nextBottomScratch;\n        var vertexNormal = vertexNormalScratch;\n\n        // First point - either loop or attach a \"perpendicular\" normal\n        var startCartographic = cartographics[0];\n        var nextCartographic = cartographics[1];\n\n        var prestartCartographic = cartographics[cartographicsLength - 1];\n        previousBottom = getPosition(ellipsoid, prestartCartographic, minHeight, previousBottom);\n        nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n        vertexBottom = getPosition(ellipsoid, startCartographic, minHeight, vertexBottom);\n        vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n        if (loop) {\n            vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n        } else {\n            vertexNormal = computeRightNormal(startCartographic, nextCartographic, maxHeight, ellipsoid, vertexNormal);\n        }\n\n        Cartesian3.pack(vertexNormal, normalsArray, 0);\n        Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n        Cartesian3.pack(vertexTop, topPositionsArray, 0);\n        cartographicsArray.push(startCartographic.latitude);\n        cartographicsArray.push(startCartographic.longitude);\n\n        interpolateSegment(startCartographic, nextCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n\n        // All inbetween points\n        for (i = 1; i < cartographicsLength - 1; ++i) {\n            previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n            vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n            var vertexCartographic = cartographics[i];\n            getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n            getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n\n            computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n\n            index = normalsArray.length;\n            Cartesian3.pack(vertexNormal, normalsArray, index);\n            Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n            Cartesian3.pack(vertexTop, topPositionsArray, index);\n            cartographicsArray.push(vertexCartographic.latitude);\n            cartographicsArray.push(vertexCartographic.longitude);\n\n            interpolateSegment(cartographics[i], cartographics[i + 1], minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n        }\n\n        // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n        var endCartographic = cartographics[cartographicsLength - 1];\n        var preEndCartographic = cartographics[cartographicsLength - 2];\n\n        vertexBottom = getPosition(ellipsoid, endCartographic, minHeight, vertexBottom);\n        vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n        if (loop) {\n            var postEndCartographic = cartographics[0];\n            previousBottom = getPosition(ellipsoid, preEndCartographic, minHeight, previousBottom);\n            nextBottom = getPosition(ellipsoid, postEndCartographic, minHeight, nextBottom);\n\n            vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n        } else {\n            vertexNormal = computeRightNormal(preEndCartographic, endCartographic, maxHeight, ellipsoid, vertexNormal);\n        }\n\n        index = normalsArray.length;\n        Cartesian3.pack(vertexNormal, normalsArray, index);\n        Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n        Cartesian3.pack(vertexTop, topPositionsArray, index);\n        cartographicsArray.push(endCartographic.latitude);\n        cartographicsArray.push(endCartographic.longitude);\n\n        if (loop) {\n            interpolateSegment(endCartographic, startCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n            index = normalsArray.length;\n            for (i = 0; i < 3; ++i) {\n                normalsArray[index + i] = normalsArray[i];\n                bottomPositionsArray[index + i] = bottomPositionsArray[i];\n                topPositionsArray[index + i] = topPositionsArray[i];\n            }\n            cartographicsArray.push(startCartographic.latitude);\n            cartographicsArray.push(startCartographic.longitude);\n        }\n\n        return generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes);\n    };\n\n    // If the end normal angle is too steep compared to the direction of the line segment,\n    // \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n    // For ultra precision we would want to project into a plane, but in practice this is sufficient.\n    var lineDirectionScratch = new Cartesian3();\n    var matrix3Scratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n    function breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n        var lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n\n        var dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n        if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n            var vertexUp = direction(endTop, endBottom, vertexUpScratch);\n            var angle = dot < MITER_BREAK_LARGE ? CesiumMath.PI_OVER_TWO : -CesiumMath.PI_OVER_TWO;\n            var quaternion = Quaternion.fromAxisAngle(vertexUp, angle, quaternionScratch);\n            var rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n            Matrix3.multiplyByVector(rotationMatrix, endGeometryNormal, endGeometryNormal);\n            return true;\n        }\n        return false;\n    }\n\n    var endPosCartographicScratch = new Cartographic();\n    var normalStartpointScratch = new Cartesian3();\n    var normalEndpointScratch = new Cartesian3();\n    function projectNormal(projection, cartographic, normal, projectedPosition, result) {\n        var position = Cartographic.toCartesian(cartographic, projection._ellipsoid, normalStartpointScratch);\n        var normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n        var flipNormal = false;\n\n        var ellipsoid = projection._ellipsoid;\n        var normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\n        // If normal crosses the IDL, go the other way and flip the result.\n        // In practice this almost never happens because the cartographic start\n        // and end points of each segment are \"nudged\" to be on the same side\n        // of the IDL and slightly away from the IDL.\n        if (Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) > CesiumMath.PI_OVER_TWO) {\n            flipNormal = true;\n            normalEndpoint = Cartesian3.subtract(position, normal, normalEndpointScratch);\n            normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\n        }\n\n        normalEndpointCartographic.height = 0.0;\n        var normalEndpointProjected = projection.project(normalEndpointCartographic, result);\n        result = Cartesian3.subtract(normalEndpointProjected, projectedPosition, result);\n        result.z = 0.0;\n        result = Cartesian3.normalize(result, result);\n        if (flipNormal) {\n            Cartesian3.negate(result, result);\n        }\n        return result;\n    }\n\n    var adjustHeightNormalScratch = new Cartesian3();\n    var adjustHeightOffsetScratch = new Cartesian3();\n    function adjustHeights(bottom, top, minHeight, maxHeight, adjustHeightBottom, adjustHeightTop) {\n        // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n        var adjustHeightNormal = Cartesian3.subtract(top, bottom, adjustHeightNormalScratch);\n        Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n\n        var distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n        var adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForBottom, adjustHeightOffsetScratch);\n        Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n\n        var distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n        adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForTop, adjustHeightOffsetScratch);\n        Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n    }\n\n    var nudgeDirectionScratch = new Cartesian3();\n    function nudgeXZ(start, end) {\n        var startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n        var endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n        var offset = nudgeDirectionScratch;\n        // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n        if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n            offset = direction(end, start, offset);\n            Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n            Cartesian3.add(start, offset, start);\n        } else if (CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n            offset = direction(start, end, offset);\n            Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n            Cartesian3.add(end, offset, end);\n        }\n    }\n\n    // \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n    // Nudge amounts are tiny, basically just an IDL flip.\n    // Only used for 2D/CV.\n    function nudgeCartographic(start, end) {\n        var absStartLon = Math.abs(start.longitude);\n        var absEndLon = Math.abs(end.longitude);\n        if (CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\n            var endSign = CesiumMath.sign(end.longitude);\n            start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n            return 1;\n        } else if (CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\n            var startSign = CesiumMath.sign(start.longitude);\n            end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n            return 2;\n        }\n        return 0;\n    }\n\n    var startCartographicScratch = new Cartographic();\n    var endCartographicScratch = new Cartographic();\n\n    var segmentStartTopScratch = new Cartesian3();\n    var segmentEndTopScratch = new Cartesian3();\n    var segmentStartBottomScratch = new Cartesian3();\n    var segmentEndBottomScratch = new Cartesian3();\n    var segmentStartNormalScratch = new Cartesian3();\n    var segmentEndNormalScratch = new Cartesian3();\n\n    var getHeightCartographics = [startCartographicScratch, endCartographicScratch];\n    var getHeightRectangleScratch = new Rectangle();\n\n    var adjustHeightStartTopScratch = new Cartesian3();\n    var adjustHeightEndTopScratch = new Cartesian3();\n    var adjustHeightStartBottomScratch = new Cartesian3();\n    var adjustHeightEndBottomScratch = new Cartesian3();\n\n    var segmentStart2DScratch = new Cartesian3();\n    var segmentEnd2DScratch = new Cartesian3();\n    var segmentStartNormal2DScratch = new Cartesian3();\n    var segmentEndNormal2DScratch = new Cartesian3();\n\n    var offsetScratch = new Cartesian3();\n    var startUpScratch = new Cartesian3();\n    var endUpScratch = new Cartesian3();\n    var rightScratch = new Cartesian3();\n    var startPlaneNormalScratch = new Cartesian3();\n    var endPlaneNormalScratch = new Cartesian3();\n    var encodeScratch = new EncodedCartesian3();\n\n    var encodeScratch2D = new EncodedCartesian3();\n    var forwardOffset2DScratch = new Cartesian3();\n    var right2DScratch = new Cartesian3();\n\n    var normalNudgeScratch = new Cartesian3();\n\n    var scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n    // Winding order is reversed so each segment's volume is inside-out\n    var REFERENCE_INDICES = [\n        0, 2, 1, 0, 3, 2, // right\n        0, 7, 3, 0, 4, 7, // start\n        0, 5, 4, 0, 1, 5, // bottom\n        5, 7, 4, 5, 6, 7, // left\n        5, 2, 6, 5, 1, 2, // end\n        3, 6, 2, 3, 7, 6 // top\n    ];\n    var REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n    // Decompose the \"wall\" into a series of shadow volumes.\n    // Each shadow volume's vertices encode a description of the line it contains,\n    // including mitering planes at the end points, a plane along the line itself,\n    // and attributes for computing length-wise texture coordinates.\n    function generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes) {\n        var i;\n        var index;\n        var ellipsoid = projection._ellipsoid;\n\n        // Each segment will have 8 vertices\n        var segmentCount = (bottomPositionsArray.length / 3) - 1;\n        var vertexCount = segmentCount * 8;\n        var arraySizeVec4 = vertexCount * 4;\n        var indexCount = segmentCount * 36;\n\n        var indices = vertexCount > 65535 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);\n        var positionsArray = new Float64Array(vertexCount * 3);\n\n        var startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n        var startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n        var startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n        var endNormalAndTextureCoordinateNormalizationX = new Float32Array(arraySizeVec4);\n        var rightNormalAndTextureCoordinateNormalizationY = new Float32Array(arraySizeVec4);\n\n        var startHiLo2D;\n        var offsetAndRight2D;\n        var startEndNormals2D;\n        var texcoordNormalization2D;\n\n        if (compute2dAttributes) {\n            startHiLo2D = new Float32Array(arraySizeVec4);\n            offsetAndRight2D = new Float32Array(arraySizeVec4);\n            startEndNormals2D = new Float32Array(arraySizeVec4);\n            texcoordNormalization2D = new Float32Array(vertexCount * 2);\n        }\n\n        /*** Compute total lengths for texture coordinate normalization ***/\n        // 2D\n        var cartographicsLength = cartographicsArray.length / 2;\n        var length2D = 0.0;\n\n        var startCartographic = startCartographicScratch;\n        startCartographic.height = 0.0;\n        var endCartographic = endCartographicScratch;\n        endCartographic.height = 0.0;\n\n        var segmentStartCartesian = segmentStartTopScratch;\n        var segmentEndCartesian = segmentEndTopScratch;\n\n        if (compute2dAttributes) {\n            index = 0;\n            for (i = 1; i < cartographicsLength; i++) {\n                // Don't clone anything from previous segment b/c possible IDL touch\n                startCartographic.latitude = cartographicsArray[index];\n                startCartographic.longitude = cartographicsArray[index + 1];\n                endCartographic.latitude = cartographicsArray[index + 2];\n                endCartographic.longitude = cartographicsArray[index + 3];\n\n                segmentStartCartesian = projection.project(startCartographic, segmentStartCartesian);\n                segmentEndCartesian = projection.project(endCartographic, segmentEndCartesian);\n                length2D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n                index += 2;\n            }\n        }\n\n        // 3D\n        var positionsLength = topPositionsArray.length / 3;\n        segmentEndCartesian = Cartesian3.unpack(topPositionsArray, 0, segmentEndCartesian);\n        var length3D = 0.0;\n\n        index = 3;\n        for (i = 1; i < positionsLength; i++) {\n            segmentStartCartesian = Cartesian3.clone(segmentEndCartesian, segmentStartCartesian);\n            segmentEndCartesian = Cartesian3.unpack(topPositionsArray, index, segmentEndCartesian);\n            length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n            index += 3;\n        }\n\n        /*** Generate segments ***/\n        var j;\n        index = 3;\n        var cartographicsIndex = 0;\n        var vec2sWriteIndex = 0;\n        var vec3sWriteIndex = 0;\n        var vec4sWriteIndex = 0;\n        var miterBroken = false;\n\n        var endBottom = Cartesian3.unpack(bottomPositionsArray, 0, segmentEndBottomScratch);\n        var endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n        var endGeometryNormal = Cartesian3.unpack(normalsArray, 0, segmentEndNormalScratch);\n\n        if (loop) {\n            var preEndBottom = Cartesian3.unpack(bottomPositionsArray, bottomPositionsArray.length - 6, segmentStartBottomScratch);\n            if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n                // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n                endGeometryNormal = Cartesian3.negate(endGeometryNormal, endGeometryNormal);\n            }\n        }\n\n        var lengthSoFar3D = 0.0;\n        var lengthSoFar2D = 0.0;\n\n        // For translating bounding volume\n        var sumHeights = 0.0;\n\n        for (i = 0; i < segmentCount; i++) {\n            var startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n            var startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n            var startGeometryNormal = Cartesian3.clone(endGeometryNormal, segmentStartNormalScratch);\n\n            if (miterBroken) {\n                startGeometryNormal = Cartesian3.negate(startGeometryNormal, startGeometryNormal);\n            }\n\n            endBottom = Cartesian3.unpack(bottomPositionsArray, index, segmentEndBottomScratch);\n            endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n            endGeometryNormal = Cartesian3.unpack(normalsArray, index, segmentEndNormalScratch);\n\n            miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n            // 2D - don't clone anything from previous segment b/c possible IDL touch\n            startCartographic.latitude = cartographicsArray[cartographicsIndex];\n            startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n            endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n            endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n            var start2D;\n            var end2D;\n            var startGeometryNormal2D;\n            var endGeometryNormal2D;\n\n            if (compute2dAttributes) {\n                var nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n                start2D = projection.project(startCartographic, segmentStart2DScratch);\n                end2D = projection.project(endCartographic, segmentEnd2DScratch);\n                var direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n                direction2D.y = Math.abs(direction2D.y);\n\n                startGeometryNormal2D = segmentStartNormal2DScratch;\n                endGeometryNormal2D = segmentEndNormal2DScratch;\n                if (nudgeResult === 0 || Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL) {\n                    // No nudge - project the original normal\n                    // Or, if the line's angle relative to the IDL is very acute,\n                    // in which case snapping will produce oddly shaped volumes.\n                    startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\n                    endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\n                } else if (nudgeResult === 1) {\n                    // Start is close to IDL - snap start normal to align with IDL\n                    endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\n                    startGeometryNormal2D.x = 0.0;\n                    // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n                    // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n                    startGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - Math.abs(endCartographic.longitude));\n                    startGeometryNormal2D.z = 0.0;\n                } else {\n                    // End is close to IDL - snap end normal to align with IDL\n                    startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\n                    endGeometryNormal2D.x = 0.0;\n                    // If end longitude is negative and start longitude is less negative, relative right is unit Y\n                    // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n                    endGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - endCartographic.longitude);\n                    endGeometryNormal2D.z = 0.0;\n                }\n            }\n\n            /****************************************\n             * Geometry descriptors of a \"line on terrain,\"\n             * as opposed to the \"shadow volume used to draw\n             * the line on terrain\":\n             * - position of start + offset to end\n             * - start, end, and right-facing planes\n             * - encoded texture coordinate offsets\n             ****************************************/\n\n             /** 3D **/\n            var segmentLength3D = Cartesian3.distance(startTop, endTop);\n\n            var encodedStart = EncodedCartesian3.fromCartesian(startBottom, encodeScratch);\n            var forwardOffset = Cartesian3.subtract(endBottom, startBottom, offsetScratch);\n            var forward = Cartesian3.normalize(forwardOffset, rightScratch);\n\n            var startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n            startUp = Cartesian3.normalize(startUp, startUp);\n            var rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n            rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n\n            var startPlaneNormal = Cartesian3.cross(startUp, startGeometryNormal, startPlaneNormalScratch);\n            startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n\n            var endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n            endUp = Cartesian3.normalize(endUp, endUp);\n            var endPlaneNormal = Cartesian3.cross(endGeometryNormal, endUp, endPlaneNormalScratch);\n            endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n\n            var texcoordNormalization3DX = segmentLength3D / length3D;\n            var texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n            /** 2D **/\n            var segmentLength2D = 0.0;\n            var encodedStart2D;\n            var forwardOffset2D;\n            var right2D;\n            var texcoordNormalization2DX = 0.0;\n            var texcoordNormalization2DY = 0.0;\n            if (compute2dAttributes) {\n                segmentLength2D = Cartesian3.distance(start2D, end2D);\n\n                encodedStart2D = EncodedCartesian3.fromCartesian(start2D, encodeScratch2D);\n                forwardOffset2D = Cartesian3.subtract(end2D, start2D, forwardOffset2DScratch);\n\n                // Right direction is just forward direction rotated by -90 degrees around Z\n                // Similarly with plane normals\n                right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n                var swap = right2D.x;\n                right2D.x = right2D.y;\n                right2D.y = -swap;\n\n                texcoordNormalization2DX = segmentLength2D / length2D;\n                texcoordNormalization2DY = lengthSoFar2D / length2D;\n            }\n            /** Pack **/\n            for (j = 0; j < 8; j++) {\n                var vec4Index = vec4sWriteIndex + j * 4;\n                var vec2Index = vec2sWriteIndex + j * 2;\n                var wIndex = vec4Index + 3;\n\n                // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n                // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n                var rightPlaneSide = j < 4 ? 1.0 : -1.0;\n                var topBottomSide = (j === 2 || j === 3 || j === 6 || j === 7) ? 1.0 : -1.0;\n\n                // 3D\n                Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n                startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n\n                Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n                startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n\n                Cartesian3.pack(startPlaneNormal, startNormalAndForwardOffsetZ, vec4Index);\n                startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n\n                Cartesian3.pack(endPlaneNormal, endNormalAndTextureCoordinateNormalizationX, vec4Index);\n                endNormalAndTextureCoordinateNormalizationX[wIndex] = texcoordNormalization3DX * rightPlaneSide;\n\n                Cartesian3.pack(rightNormal, rightNormalAndTextureCoordinateNormalizationY, vec4Index);\n\n                var texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n                if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n                    texcoordNormalization = 9.0; // some value greater than 1.0\n                }\n                rightNormalAndTextureCoordinateNormalizationY[wIndex] = texcoordNormalization;\n\n                // 2D\n                if (compute2dAttributes) {\n                    startHiLo2D[vec4Index] = encodedStart2D.high.x;\n                    startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n                    startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n                    startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n\n                    startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n                    startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n                    startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n                    startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n\n                    offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n                    offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n                    offsetAndRight2D[vec4Index + 2] = right2D.x;\n                    offsetAndRight2D[vec4Index + 3] = right2D.y;\n\n                    texcoordNormalization2D[vec2Index] = texcoordNormalization2DX * rightPlaneSide;\n\n                    texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n                    if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n                        texcoordNormalization = 9.0; // some value greater than 1.0\n                    }\n                    texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n                }\n            }\n\n            // Adjust height of volume in 3D\n            var adjustHeightStartBottom = adjustHeightStartBottomScratch;\n            var adjustHeightEndBottom = adjustHeightEndBottomScratch;\n            var adjustHeightStartTop = adjustHeightStartTopScratch;\n            var adjustHeightEndTop = adjustHeightEndTopScratch;\n\n            var getHeightsRectangle = Rectangle.fromCartographicArray(getHeightCartographics, getHeightRectangleScratch);\n            var minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(getHeightsRectangle, ellipsoid);\n            var minHeight = minMaxHeights.minimumTerrainHeight;\n            var maxHeight = minMaxHeights.maximumTerrainHeight;\n\n            sumHeights += minHeight;\n            sumHeights += maxHeight;\n\n            adjustHeights(startBottom, startTop, minHeight, maxHeight, adjustHeightStartBottom, adjustHeightStartTop);\n            adjustHeights(endBottom, endTop, minHeight, maxHeight, adjustHeightEndBottom, adjustHeightEndTop);\n\n            // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n            var normalNudge = Cartesian3.multiplyByScalar(rightNormal, CesiumMath.EPSILON5, normalNudgeScratch);\n            Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\n            Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n            Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n            Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n            // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n            nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n            nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n            Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n            Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n            Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n            Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n\n            normalNudge = Cartesian3.multiplyByScalar(rightNormal, -2.0 * CesiumMath.EPSILON5, normalNudgeScratch);\n            Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\n            Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n            Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n            Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n            nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n            nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n            Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex + 12);\n            Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 15);\n            Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n            Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n\n            cartographicsIndex += 2;\n            index += 3;\n\n            vec2sWriteIndex += 16;\n            vec3sWriteIndex += 24;\n            vec4sWriteIndex += 32;\n\n            lengthSoFar3D += segmentLength3D;\n            lengthSoFar2D += segmentLength2D;\n        }\n\n        index = 0;\n        var indexOffset = 0;\n        for (i = 0; i < segmentCount; i++) {\n            for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n                indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n            }\n            indexOffset += 8;\n            index += REFERENCE_INDICES_LENGTH;\n        }\n\n        var boundingSpheres = scratchBoundingSpheres;\n        BoundingSphere.fromVertices(bottomPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[0]);\n        BoundingSphere.fromVertices(topPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[1]);\n        var boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n        // Adjust bounding sphere height and radius to cover more of the volume\n        boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n\n        var attributes = {\n            position : new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                normalize : false,\n                values : positionsArray\n            }),\n            startHiAndForwardOffsetX : getVec4GeometryAttribute(startHiAndForwardOffsetX),\n            startLoAndForwardOffsetY : getVec4GeometryAttribute(startLoAndForwardOffsetY),\n            startNormalAndForwardOffsetZ : getVec4GeometryAttribute(startNormalAndForwardOffsetZ),\n            endNormalAndTextureCoordinateNormalizationX : getVec4GeometryAttribute(endNormalAndTextureCoordinateNormalizationX),\n            rightNormalAndTextureCoordinateNormalizationY : getVec4GeometryAttribute(rightNormalAndTextureCoordinateNormalizationY)\n        };\n\n        if (compute2dAttributes) {\n            attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n            attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n            attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n            attributes.texcoordNormalization2D = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                normalize : false,\n                values : texcoordNormalization2D\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            boundingSphere : boundingSphere\n        });\n    }\n\n    function getVec4GeometryAttribute(typedArray) {\n        return new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 4,\n            normalize : false,\n            values : typedArray\n        });\n    }\n\n    /**\n     * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n     * Exposed for testing.\n     *\n     * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n     * @param {Cartographic} cartographic The cartographic origin point of the normal.\n     *   Used to check if the normal crosses the IDL during projection.\n     * @param {Cartesian3} normal The normal in 3D.\n     * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n     * @param {Cartesian3} result Result parameter on which to store the projected normal.\n     * @private\n     */\n    GroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport defined from '../Core/defined.js';\nimport GroundPolylineGeometry from '../Core/GroundPolylineGeometry.js';\n\n    function createGroundPolylineGeometry(groundPolylineGeometry, offset) {\n        return ApproximateTerrainHeights.initialize()\n            .then(function() {\n                if (defined(offset)) {\n                    groundPolylineGeometry = GroundPolylineGeometry.unpack(groundPolylineGeometry, offset);\n                }\n                return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\n            });\n    }\nexport default createGroundPolylineGeometry;\n"],"names":["defaultValue","Ellipsoid","Rectangle","GeographicProjection","Check","CesiumMath","defined","Cartesian2","Cartesian3","Cartographic","BoundingSphere","Resource","buildModuleUrl","DeveloperError","WebMercatorProjection","ArcType","EllipsoidGeodesic","EllipsoidRhumbLine","Plane","IntersectionTests","arrayRemoveDuplicates","Matrix3","Quaternion","EncodedCartesian3","GeometryAttribute","ComponentDatatype","Geometry"],"mappings":"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"}