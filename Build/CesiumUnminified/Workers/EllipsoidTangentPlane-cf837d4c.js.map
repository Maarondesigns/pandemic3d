{"version":3,"file":"EllipsoidTangentPlane-cf837d4c.js","sources":["../../../../Source/Core/AxisAlignedBoundingBox.js","../../../../Source/Core/EllipsoidTangentPlane.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Intersect from './Intersect.js';\n\n    /**\n     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n     * @alias AxisAlignedBoundingBox\n     * @constructor\n     *\n     * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n     * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n     * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n     *\n     * @see BoundingSphere\n     * @see BoundingRectangle\n     */\n    function AxisAlignedBoundingBox(minimum, maximum, center) {\n        /**\n         * The minimum point defining the bounding box.\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n\n        /**\n         * The maximum point defining the bounding box.\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\n\n        //If center was not defined, compute it.\n        if (!defined(center)) {\n            center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n        } else {\n            center = Cartesian3.clone(center);\n        }\n\n        /**\n         * The center point of the bounding box.\n         * @type {Cartesian3}\n         */\n        this.center = center;\n    }\n\n    /**\n     * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n     * finding the points spaced the farthest apart on the x, y, and z axes.\n     *\n     * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n     *\n     * @example\n     * // Compute an axis aligned bounding box enclosing two points.\n     * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n     */\n    AxisAlignedBoundingBox.fromPoints = function(positions, result) {\n        if (!defined(result)) {\n            result = new AxisAlignedBoundingBox();\n        }\n\n        if (!defined(positions) || positions.length === 0) {\n            result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n            result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            return result;\n        }\n\n        var minimumX = positions[0].x;\n        var minimumY = positions[0].y;\n        var minimumZ = positions[0].z;\n\n        var maximumX = positions[0].x;\n        var maximumY = positions[0].y;\n        var maximumZ = positions[0].z;\n\n        var length = positions.length;\n        for ( var i = 1; i < length; i++) {\n            var p = positions[i];\n            var x = p.x;\n            var y = p.y;\n            var z = p.z;\n\n            minimumX = Math.min(x, minimumX);\n            maximumX = Math.max(x, maximumX);\n            minimumY = Math.min(y, minimumY);\n            maximumY = Math.max(y, maximumY);\n            minimumZ = Math.min(z, minimumZ);\n            maximumZ = Math.max(z, maximumZ);\n        }\n\n        var minimum = result.minimum;\n        minimum.x = minimumX;\n        minimum.y = minimumY;\n        minimum.z = minimumZ;\n\n        var maximum = result.maximum;\n        maximum.x = maximumX;\n        maximum.y = maximumY;\n        maximum.z = maximumZ;\n\n        result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n        return result;\n    };\n\n    /**\n     * Duplicates a AxisAlignedBoundingBox instance.\n     *\n     * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n     */\n    AxisAlignedBoundingBox.clone = function(box, result) {\n        if (!defined(box)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n        }\n\n        result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n        result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n        result.center = Cartesian3.clone(box.center, result.center);\n        return result;\n    };\n\n    /**\n     * Compares the provided AxisAlignedBoundingBox componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    AxisAlignedBoundingBox.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                Cartesian3.equals(left.center, right.center) &&\n                Cartesian3.equals(left.minimum, right.minimum) &&\n                Cartesian3.equals(left.maximum, right.maximum));\n    };\n\n    var intersectScratch = new Cartesian3();\n    /**\n     * Determines which side of a plane a box is located.\n     *\n     * @param {AxisAlignedBoundingBox} box The bounding box to test.\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n     *                      intersects the plane.\n     */\n    AxisAlignedBoundingBox.intersectPlane = function(box, plane) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('box', box);\n        Check.defined('plane', plane);\n        //>>includeEnd('debug');\n\n        intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);\n        var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n        var normal = plane.normal;\n        var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n        var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n        if (s - e > 0) {\n            return Intersect.INSIDE;\n        }\n\n        if (s + e < 0) {\n            //Not in front because normals point inward\n            return Intersect.OUTSIDE;\n        }\n\n        return Intersect.INTERSECTING;\n    };\n\n    /**\n     * Duplicates this AxisAlignedBoundingBox instance.\n     *\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n     */\n    AxisAlignedBoundingBox.prototype.clone = function(result) {\n        return AxisAlignedBoundingBox.clone(this, result);\n    };\n\n    /**\n     * Determines which side of a plane this box is located.\n     *\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n     *                      intersects the plane.\n     */\n    AxisAlignedBoundingBox.prototype.intersectPlane = function(plane) {\n        return AxisAlignedBoundingBox.intersectPlane(this, plane);\n    };\n\n    /**\n     * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    AxisAlignedBoundingBox.prototype.equals = function(right) {\n        return AxisAlignedBoundingBox.equals(this, right);\n    };\nexport default AxisAlignedBoundingBox;\n","import AxisAlignedBoundingBox from './AxisAlignedBoundingBox.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartesian4 from './Cartesian4.js';\nimport Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport IntersectionTests from './IntersectionTests.js';\nimport Matrix4 from './Matrix4.js';\nimport Plane from './Plane.js';\nimport Ray from './Ray.js';\nimport Transforms from './Transforms.js';\n\n    var scratchCart4 = new Cartesian4();\n    /**\n     * A plane tangent to the provided ellipsoid at the provided origin.\n     * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n     * If origin is at the center of the ellipsoid, an exception will be thrown.\n     * @alias EllipsoidTangentPlane\n     * @constructor\n     *\n     * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n     *\n     * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n     */\n    function EllipsoidTangentPlane(origin, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('origin', origin);\n        //>>includeEnd('debug');\n\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(origin)) {\n            throw new DeveloperError('origin must not be at the center of the ellipsoid.');\n        }\n        //>>includeEnd('debug');\n\n        var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n        this._ellipsoid = ellipsoid;\n        this._origin = origin;\n        this._xAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 0, scratchCart4));\n        this._yAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 1, scratchCart4));\n\n        var normal = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 2, scratchCart4));\n        this._plane = Plane.fromPointNormal(origin, normal);\n    }\n\n    Object.defineProperties(EllipsoidTangentPlane.prototype, {\n        /**\n         * Gets the ellipsoid.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @type {Ellipsoid}\n         */\n        ellipsoid : {\n            get : function() {\n                return this._ellipsoid;\n            }\n        },\n\n        /**\n         * Gets the origin.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @type {Cartesian3}\n         */\n        origin : {\n            get : function() {\n                return this._origin;\n            }\n        },\n\n        /**\n         * Gets the plane which is tangent to the ellipsoid.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Plane}\n         */\n        plane : {\n            get : function() {\n                return this._plane;\n            }\n        },\n\n        /**\n         * Gets the local X-axis (east) of the tangent plane.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Cartesian3}\n         */\n        xAxis : {\n            get : function() {\n                return this._xAxis;\n            }\n        },\n\n        /**\n         * Gets the local Y-axis (north) of the tangent plane.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Cartesian3}\n         */\n        yAxis : {\n            get : function() {\n                return this._yAxis;\n            }\n        },\n\n        /**\n         * Gets the local Z-axis (up) of the tangent plane.\n         * @member EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Cartesian3}\n         */\n        zAxis : {\n            get : function() {\n                return this._plane.normal;\n            }\n        }\n    });\n\n    var tmp = new AxisAlignedBoundingBox();\n    /**\n     * Creates a new instance from the provided ellipsoid and the center\n     * point of the provided Cartesians.\n     *\n     * @param {Cartesian3} cartesians The list of positions surrounding the center point.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n     */\n    EllipsoidTangentPlane.fromPoints = function(cartesians, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('cartesians', cartesians);\n        //>>includeEnd('debug');\n\n        var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n        return new EllipsoidTangentPlane(box.center, ellipsoid);\n    };\n\n    var scratchProjectPointOntoPlaneRay = new Ray();\n    var scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n    /**\n     * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n     *\n     * @param {Cartesian3} cartesian The point to project.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n     */\n    EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('cartesian', cartesian);\n        //>>includeEnd('debug');\n\n        var ray = scratchProjectPointOntoPlaneRay;\n        ray.origin = cartesian;\n        Cartesian3.normalize(cartesian, ray.direction);\n\n        var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        if (!defined(intersectionPoint)) {\n            Cartesian3.negate(ray.direction, ray.direction);\n            intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        }\n\n        if (defined(intersectionPoint)) {\n            var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n            var x = Cartesian3.dot(this._xAxis, v);\n            var y = Cartesian3.dot(this._yAxis, v);\n\n            if (!defined(result)) {\n                return new Cartesian2(x, y);\n            }\n            result.x = x;\n            result.y = y;\n            return result;\n        }\n        return undefined;\n    };\n\n    /**\n     * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n     * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n     *\n     * @see EllipsoidTangentPlane.projectPointOntoPlane\n     *\n     * @param {Cartesian3[]} cartesians The array of points to project.\n     * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n     * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n     */\n    EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(cartesians, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('cartesians', cartesians);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var count = 0;\n        var length = cartesians.length;\n        for ( var i = 0; i < length; i++) {\n            var p = this.projectPointOntoPlane(cartesians[i], result[count]);\n            if (defined(p)) {\n                result[count] = p;\n                count++;\n            }\n        }\n        result.length = count;\n        return result;\n    };\n\n    /**\n     * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n     *\n     * @param {Cartesian3} cartesian The point to project.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n     */\n    EllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('cartesian', cartesian);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian2();\n        }\n\n        var ray = scratchProjectPointOntoPlaneRay;\n        ray.origin = cartesian;\n        Cartesian3.clone(this._plane.normal, ray.direction);\n\n        var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        if (!defined(intersectionPoint)) {\n            Cartesian3.negate(ray.direction, ray.direction);\n            intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        }\n\n        var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n        var x = Cartesian3.dot(this._xAxis, v);\n        var y = Cartesian3.dot(this._yAxis, v);\n\n        result.x = x;\n        result.y = y;\n        return result;\n    };\n\n    /**\n     * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n     *\n     * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n     *\n     * @param {Cartesian3[]} cartesians The array of points to project.\n     * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n     * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n     */\n    EllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function(cartesians, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('cartesians', cartesians);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var length = cartesians.length;\n        result.length = length;\n        for (var i = 0; i < length; i++) {\n            result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n        }\n        return result;\n    };\n\n    var projectPointsOntoEllipsoidScratch = new Cartesian3();\n    /**\n     * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n     *\n     * @param {Cartesian2} cartesian The points to project.\n     * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n     */\n    EllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('cartesian', cartesian);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        var ellipsoid = this._ellipsoid;\n        var origin = this._origin;\n        var xAxis = this._xAxis;\n        var yAxis = this._yAxis;\n        var tmp = projectPointsOntoEllipsoidScratch;\n\n        Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n        result = Cartesian3.add(origin, tmp, result);\n        Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n        Cartesian3.add(result, tmp, result);\n        ellipsoid.scaleToGeocentricSurface(result, result);\n\n        return result;\n    };\n\n    /**\n     * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n     *\n     * @param {Cartesian2[]} cartesians The array of points to project.\n     * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n     * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n     */\n    EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(cartesians, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('cartesians', cartesians);\n        //>>includeEnd('debug');\n\n        var length = cartesians.length;\n        if (!defined(result)) {\n            result = new Array(length);\n        } else {\n            result.length = length;\n        }\n\n        for ( var i = 0; i < length; ++i) {\n            result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n        }\n\n        return result;\n    };\nexport default EllipsoidTangentPlane;\n"],"names":["Cartesian3","defaultValue","defined","Check","Intersect","Cartesian4","Ellipsoid","DeveloperError","Transforms","Matrix4","Plane","Ray","IntersectionTests","Cartesian2"],"mappings":"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"}