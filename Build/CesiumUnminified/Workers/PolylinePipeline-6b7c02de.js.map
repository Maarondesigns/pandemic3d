{"version":3,"file":"PolylinePipeline-6b7c02de.js","sources":["../../../../Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\nimport IntersectionTests from './IntersectionTests.js';\nimport CesiumMath from './Math.js';\nimport Matrix4 from './Matrix4.js';\nimport Plane from './Plane.js';\n\n    /**\n     * @private\n     */\n    var PolylinePipeline = {};\n\n    PolylinePipeline.numberOfPoints = function(p0, p1, minDistance) {\n        var distance = Cartesian3.distance(p0, p1);\n        return Math.ceil(distance / minDistance);\n    };\n\n    PolylinePipeline.numberOfPointsRhumbLine = function(p0, p1, granularity) {\n        var radiansDistanceSquared = Math.pow((p0.longitude - p1.longitude), 2) + Math.pow((p0.latitude - p1.latitude), 2);\n        return Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)));\n    };\n\n    var cartoScratch = new Cartographic();\n    PolylinePipeline.extractHeights = function(positions, ellipsoid) {\n        var length = positions.length;\n        var heights = new Array(length);\n        for (var i = 0; i < length; i++) {\n            var p = positions[i];\n            heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n        }\n        return heights;\n    };\n\n    var wrapLongitudeInversMatrix = new Matrix4();\n    var wrapLongitudeOrigin = new Cartesian3();\n    var wrapLongitudeXZNormal = new Cartesian3();\n    var wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n    var wrapLongitudeYZNormal = new Cartesian3();\n    var wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n    var wrapLongitudeIntersection = new Cartesian3();\n    var wrapLongitudeOffset = new Cartesian3();\n\n    var subdivideHeightsScratchArray = [];\n\n    function subdivideHeights(numPoints, h0, h1) {\n        var heights = subdivideHeightsScratchArray;\n        heights.length = numPoints;\n\n        var i;\n        if (h0 === h1) {\n            for (i = 0; i < numPoints; i++) {\n                heights[i] = h0;\n            }\n            return heights;\n        }\n\n        var dHeight = h1 - h0;\n        var heightPerVertex = dHeight / numPoints;\n\n        for (i = 0; i < numPoints; i++) {\n            var h = h0 + i*heightPerVertex;\n            heights[i] = h;\n        }\n\n        return heights;\n    }\n\n    var carto1 = new Cartographic();\n    var carto2 = new Cartographic();\n    var cartesian = new Cartesian3();\n    var scaleFirst = new Cartesian3();\n    var scaleLast = new Cartesian3();\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\n    var ellipsoidRhumb = new EllipsoidRhumbLine();\n\n    //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n    //Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n    //and this prevents duplication of end point.\n    function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {\n        var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n        var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n        var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n        var start = ellipsoid.cartesianToCartographic(first, carto1);\n        var end = ellipsoid.cartesianToCartographic(last, carto2);\n        var heights = subdivideHeights(numPoints, h0, h1);\n\n        ellipsoidGeodesic.setEndPoints(start, end);\n        var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;\n\n        var index = offset;\n        start.height = h0;\n        var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n        Cartesian3.pack(cart, array, index);\n        index += 3;\n\n        for (var i = 1; i < numPoints; i++) {\n            var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n            carto.height = heights[i];\n            cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n            Cartesian3.pack(cart, array, index);\n            index += 3;\n        }\n\n        return index;\n    }\n\n    //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n    //Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n    //and this prevents duplication of end point.\n    function generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, array, offset) {\n        var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n        var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n        var start = ellipsoid.cartesianToCartographic(first, carto1);\n        var end = ellipsoid.cartesianToCartographic(last, carto2);\n\n        var numPoints = PolylinePipeline.numberOfPointsRhumbLine(start, end, granularity);\n        var heights = subdivideHeights(numPoints, h0, h1);\n\n        if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n            ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n        }\n        ellipsoidRhumb.setEndPoints(start, end);\n        var surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\n\n        var index = offset;\n        start.height = h0;\n        var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n        Cartesian3.pack(cart, array, index);\n        index += 3;\n\n        for (var i = 1; i < numPoints; i++) {\n            var carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n            carto.height = heights[i];\n            cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n            Cartesian3.pack(cart, array, index);\n            index += 3;\n        }\n\n        return index;\n    }\n\n    /**\n     * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n     *\n     * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n     * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n     * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n     * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n     * The matrix is not verified to be in the proper form.\n     * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n     * <code>segments</code> property.\n     *\n     *\n     * @example\n     * var polylines = new Cesium.PolylineCollection();\n     * var polyline = polylines.add(...);\n     * var positions = polyline.positions;\n     * var modelMatrix = polylines.modelMatrix;\n     * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n     *\n     * @see PolygonPipeline.wrapLongitude\n     * @see Polyline\n     * @see PolylineCollection\n     */\n    PolylinePipeline.wrapLongitude = function(positions, modelMatrix) {\n        var cartesians = [];\n        var segments = [];\n\n        if (defined(positions) && positions.length > 0) {\n            modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n            var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);\n\n            var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);\n            var xzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal), wrapLongitudeXZNormal);\n            var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\n            var yzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal), wrapLongitudeYZNormal);\n            var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\n\n            var count = 1;\n            cartesians.push(Cartesian3.clone(positions[0]));\n            var prev = cartesians[0];\n\n            var length = positions.length;\n            for (var i = 1; i < length; ++i) {\n                var cur = positions[i];\n\n                // intersects the IDL if either endpoint is on the negative side of the yz-plane\n                if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {\n                    // and intersects the xz-plane\n                    var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);\n                    if (defined(intersection)) {\n                        // move point on the xz-plane slightly away from the plane\n                        var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);\n                        if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n                            Cartesian3.negate(offset, offset);\n                        }\n\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n                        segments.push(count + 1);\n\n                        Cartesian3.negate(offset, offset);\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n                        count = 1;\n                    }\n                }\n\n                cartesians.push(Cartesian3.clone(positions[i]));\n                count++;\n\n                prev = cur;\n            }\n\n            segments.push(count);\n        }\n\n        return {\n            positions : cartesians,\n            lengths : segments\n        };\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateArc = function(options) {\n        if (!defined(options)) {\n            options = {};\n        }\n        var positions = options.positions;\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(positions)) {\n            throw new DeveloperError('options.positions is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = positions.length;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var height = defaultValue(options.height, 0);\n        var hasHeightArray = Array.isArray(height);\n\n        if (length < 1) {\n            return [];\n        } else if (length === 1) {\n            var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n            height = hasHeightArray ? height[0] : height;\n            if (height !== 0) {\n                var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n                Cartesian3.multiplyByScalar(n, height, n);\n                Cartesian3.add(p, n, p);\n            }\n\n            return [p.x, p.y, p.z];\n        }\n\n        var minDistance = options.minDistance;\n        if (!defined(minDistance)) {\n            var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n            minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n        }\n\n        var numPoints = 0;\n        var i;\n\n        for (i = 0; i < length -1; i++) {\n            numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i+1], minDistance);\n        }\n\n        var arrayLength = (numPoints + 1) * 3;\n        var newPositions = new Array(arrayLength);\n        var offset = 0;\n\n        for (i = 0; i < length - 1; i++) {\n            var p0 = positions[i];\n            var p1 = positions[i + 1];\n\n            var h0 = hasHeightArray ? height[i] : height;\n            var h1 = hasHeightArray ? height[i + 1] : height;\n\n            offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);\n        }\n\n        subdivideHeightsScratchArray.length = 0;\n\n        var lastPoint = positions[length - 1];\n        var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n        carto.height = hasHeightArray ? height[length - 1] : height;\n        var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n        Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n        return newPositions;\n    };\n\n    var scratchCartographic0 = new Cartographic();\n    var scratchCartographic1 = new Cartographic();\n\n    /**\n     * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateRhumbArc = function(options) {\n        if (!defined(options)) {\n            options = {};\n        }\n        var positions = options.positions;\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(positions)) {\n            throw new DeveloperError('options.positions is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = positions.length;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var height = defaultValue(options.height, 0);\n        var hasHeightArray = Array.isArray(height);\n\n        if (length < 1) {\n            return [];\n        } else if (length === 1) {\n            var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n            height = hasHeightArray ? height[0] : height;\n            if (height !== 0) {\n                var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n                Cartesian3.multiplyByScalar(n, height, n);\n                Cartesian3.add(p, n, p);\n            }\n\n            return [p.x, p.y, p.z];\n        }\n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n        var numPoints = 0;\n        var i;\n\n        var c0 = ellipsoid.cartesianToCartographic(positions[0], scratchCartographic0);\n        var c1;\n        for (i = 0; i < length - 1; i++) {\n            c1 = ellipsoid.cartesianToCartographic(positions[i + 1], scratchCartographic1);\n            numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n            c0 = Cartographic.clone(c1, scratchCartographic0);\n        }\n\n        var arrayLength = (numPoints + 1) * 3;\n        var newPositions = new Array(arrayLength);\n        var offset = 0;\n\n        for (i = 0; i < length - 1; i++) {\n            var p0 = positions[i];\n            var p1 = positions[i + 1];\n\n            var h0 = hasHeightArray ? height[i] : height;\n            var h1 = hasHeightArray ? height[i + 1] : height;\n\n            offset = generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, newPositions, offset);\n        }\n\n        subdivideHeightsScratchArray.length = 0;\n\n        var lastPoint = positions[length - 1];\n        var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n        carto.height = hasHeightArray ? height[length - 1] : height;\n        var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n        Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n        return newPositions;\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateCartesianArc = function(options) {\n        var numberArray = PolylinePipeline.generateArc(options);\n        var size = numberArray.length/3;\n        var newPositions = new Array(size);\n        for (var i = 0; i < size; i++) {\n            newPositions[i] = Cartesian3.unpack(numberArray, i*3);\n        }\n        return newPositions;\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateCartesianRhumbArc = function(options) {\n        var numberArray = PolylinePipeline.generateRhumbArc(options);\n        var size = numberArray.length/3;\n        var newPositions = new Array(size);\n        for (var i = 0; i < size; i++) {\n            newPositions[i] = Cartesian3.unpack(numberArray, i*3);\n        }\n        return newPositions;\n    };\nexport default PolylinePipeline;\n"],"names":["Cartesian3","Cartographic","Matrix4","Plane","EllipsoidGeodesic","EllipsoidRhumbLine","defined","defaultValue","IntersectionTests","DeveloperError","Ellipsoid","CesiumMath"],"mappings":"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"}