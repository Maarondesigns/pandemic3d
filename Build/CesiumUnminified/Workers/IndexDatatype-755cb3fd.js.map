{"version":3,"file":"IndexDatatype-755cb3fd.js","sources":["../../../../Source/Core/IndexDatatype.js"],"sourcesContent":["import defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport CesiumMath from './Math.js';\nimport WebGLConstants from './WebGLConstants.js';\n\n    /**\n     * Constants for WebGL index datatypes.  These corresponds to the\n     * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n     *\n     * @exports IndexDatatype\n     */\n    var IndexDatatype = {\n        /**\n         * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n         * of an element in <code>Uint8Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_BYTE : WebGLConstants.UNSIGNED_BYTE,\n\n        /**\n         * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n         * of an element in <code>Uint16Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_SHORT : WebGLConstants.UNSIGNED_SHORT,\n\n        /**\n         * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n         * of an element in <code>Uint32Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_INT : WebGLConstants.UNSIGNED_INT\n    };\n\n    /**\n     * Returns the size, in bytes, of the corresponding datatype.\n     *\n     * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n     * @returns {Number} The size in bytes.\n     *\n     * @example\n     * // Returns 2\n     * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n     */\n    IndexDatatype.getSizeInBytes = function(indexDatatype) {\n        switch(indexDatatype) {\n            case IndexDatatype.UNSIGNED_BYTE:\n                return Uint8Array.BYTES_PER_ELEMENT;\n            case IndexDatatype.UNSIGNED_SHORT:\n                return Uint16Array.BYTES_PER_ELEMENT;\n            case IndexDatatype.UNSIGNED_INT:\n                return Uint32Array.BYTES_PER_ELEMENT;\n        }\n\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError('indexDatatype is required and must be a valid IndexDatatype constant.');\n        //>>includeEnd('debug');\n    };\n\n    /**\n     * Gets the datatype with a given size in bytes.\n     *\n     * @param {Number} sizeInBytes The size of a single index in bytes.\n     * @returns {IndexDatatype} The index datatype with the given size.\n     */\n    IndexDatatype.fromSizeInBytes = function(sizeInBytes) {\n        switch (sizeInBytes) {\n            case 2:\n                return IndexDatatype.UNSIGNED_SHORT;\n            case 4:\n                return IndexDatatype.UNSIGNED_INT;\n            case 1:\n                return IndexDatatype.UNSIGNED_BYTE;\n            //>>includeStart('debug', pragmas.debug);\n            default:\n                throw new DeveloperError('Size in bytes cannot be mapped to an IndexDatatype');\n            //>>includeEnd('debug');\n        }\n    };\n\n    /**\n     * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n     *\n     * @param {IndexDatatype} indexDatatype The index datatype to validate.\n     * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n     *\n     * @example\n     * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n     *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n     * }\n     */\n    IndexDatatype.validate = function(indexDatatype) {\n        return defined(indexDatatype) &&\n               (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n                indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n                indexDatatype === IndexDatatype.UNSIGNED_INT);\n    };\n\n    /**\n     * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n     * or <code>Uint32Array</code> depending on the number of vertices.\n     *\n     * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n     * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n     * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n     *\n     * @example\n     * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n     */\n    IndexDatatype.createTypedArray = function(numberOfVertices, indicesLengthOrArray) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(numberOfVertices)) {\n            throw new DeveloperError('numberOfVertices is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            return new Uint32Array(indicesLengthOrArray);\n        }\n\n        return new Uint16Array(indicesLengthOrArray);\n    };\n\n    /**\n     * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n     * or <code>Uint32Array</code> depending on the number of vertices.\n     *\n     * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n     * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n     * @param {Number} byteOffset Passed through to the typed array constructor.\n     * @param {Number} length Passed through to the typed array constructor.\n     * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n     *\n     */\n    IndexDatatype.createTypedArrayFromArrayBuffer = function(numberOfVertices, sourceArray, byteOffset, length) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(numberOfVertices)) {\n            throw new DeveloperError('numberOfVertices is required.');\n        }\n        if (!defined(sourceArray)) {\n            throw new DeveloperError('sourceArray is required.');\n        }\n        if (!defined(byteOffset)) {\n            throw new DeveloperError('byteOffset is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            return new Uint32Array(sourceArray, byteOffset, length);\n        }\n\n        return new Uint16Array(sourceArray, byteOffset, length);\n    };\nexport default Object.freeze(IndexDatatype);\n"],"names":["WebGLConstants","DeveloperError","defined","CesiumMath"],"mappings":"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"}