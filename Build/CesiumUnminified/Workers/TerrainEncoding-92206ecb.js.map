{"version":3,"file":"TerrainEncoding-92206ecb.js","sources":["../../../../Source/Core/EllipsoidalOccluder.js","../../../../Source/Core/TerrainQuantization.js","../../../../Source/Core/TerrainEncoding.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Rectangle from './Rectangle.js';\n\n    /**\n     * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n     * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n     * origin of the coordinate system.  This class uses the algorithm described in the\n     * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n     *\n     * @alias EllipsoidalOccluder\n     *\n     * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n     * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n     *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n     *        testing visibility.\n     *\n     * @constructor\n     *\n     * @example\n     * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n     * var cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n     * var occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n     * var occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n     *\n     * @private\n     */\n    function EllipsoidalOccluder(ellipsoid, cameraPosition) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('ellipsoid', ellipsoid);\n        //>>includeEnd('debug');\n\n        this._ellipsoid = ellipsoid;\n        this._cameraPosition = new Cartesian3();\n        this._cameraPositionInScaledSpace = new Cartesian3();\n        this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n        // cameraPosition fills in the above values\n        if (defined(cameraPosition)) {\n            this.cameraPosition = cameraPosition;\n        }\n    }\n\n    Object.defineProperties(EllipsoidalOccluder.prototype, {\n        /**\n         * Gets the occluding ellipsoid.\n         * @memberof EllipsoidalOccluder.prototype\n         * @type {Ellipsoid}\n         */\n        ellipsoid : {\n            get: function() {\n                return this._ellipsoid;\n            }\n        },\n        /**\n         * Gets or sets the position of the camera.\n         * @memberof EllipsoidalOccluder.prototype\n         * @type {Cartesian3}\n         */\n        cameraPosition : {\n            get : function() {\n                return this._cameraPosition;\n            },\n            set : function(cameraPosition) {\n                // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n                var ellipsoid = this._ellipsoid;\n                var cv = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);\n                var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n\n                Cartesian3.clone(cameraPosition, this._cameraPosition);\n                this._cameraPositionInScaledSpace = cv;\n                this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n            }\n        }\n    });\n\n    var scratchCartesian = new Cartesian3();\n\n    /**\n     * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n     *\n     * @param {Cartesian3} occludee The point to test for visibility.\n     * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n     *\n     * @example\n     * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n     * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n     * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n     * var point = new Cesium.Cartesian3(0, -3, -3);\n     * occluder.isPointVisible(point); //returns true\n     */\n    EllipsoidalOccluder.prototype.isPointVisible = function(occludee) {\n        var ellipsoid = this._ellipsoid;\n        var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);\n        return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\n    };\n\n    /**\n     * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n     * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n     * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n     *\n     * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n     * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n     *\n     * @example\n     * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n     * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n     * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n     * var point = new Cesium.Cartesian3(0, -3, -3);\n     * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n     * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n     */\n    EllipsoidalOccluder.prototype.isScaledSpacePointVisible = function(occludeeScaledSpacePosition) {\n        return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\n    };\n\n    var scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n    /**\n     * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n     * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n     * the ellipsoid. This is intended to be used with points generated by\n     * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n     * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n     *\n     * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n     * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n     */\n    EllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function(occludeeScaledSpacePosition, minimumHeight) {\n        var ellipsoid = this._ellipsoid;\n        var vhMagnitudeSquared;\n        var cv;\n\n        if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\n            // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n            cv = scratchCameraPositionInScaledSpaceShrunk;\n            cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n            cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n            cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n            vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n        } else {\n            cv = this._cameraPositionInScaledSpace;\n            vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n        }\n\n        return isScaledSpacePointVisible(occludeeScaledSpacePosition, cv, vhMagnitudeSquared);\n    };\n\n    /**\n     * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n     * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n     * is expressed in the ellipsoid-scaled space and is suitable for use with\n     * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n     *\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\n     *                     be normalized.\n     * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n     *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n     *                       ellipsoid's axes.\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n     */\n    EllipsoidalOccluder.prototype.computeHorizonCullingPoint = function(directionToPoint, positions, result) {\n        return computeHorizonCullingPointFromPositions(this._ellipsoid, directionToPoint, positions, result);\n    };\n\n    var scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n    /**\n     * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n     * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n     * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n     * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n     *\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\n     *                     be normalized.\n     * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n     *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n     *                       ellipsoid's axes.\n     * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n     */\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function(directionToPoint, positions, minimumHeight, result) {\n        var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\n        return computeHorizonCullingPointFromPositions(possiblyShrunkEllipsoid, directionToPoint, positions, result);\n    };\n    /**\n     * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n     * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n     * is expressed in the ellipsoid-scaled space and is suitable for use with\n     * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n     *\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\n     *                     be normalized.\n     * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n     *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n     *                   ellipsoid's axes.\n     * @param {Number} [stride=3]\n     * @param {Cartesian3} [center=Cartesian3.ZERO]\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n     */\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function(directionToPoint, vertices, stride, center, result) {\n        return computeHorizonCullingPointFromVertices(this._ellipsoid, directionToPoint, vertices, stride, center, result);\n    };\n\n    /**\n     * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n     * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n     * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n     * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n     *\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\n     *                     be normalized.\n     * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n     *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n     *                   ellipsoid's axes.\n     * @param {Number} [stride=3]\n     * @param {Cartesian3} [center=Cartesian3.ZERO]\n     * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n     */\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function(directionToPoint, vertices, stride, center, minimumHeight, result) {\n        var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\n        return computeHorizonCullingPointFromVertices(possiblyShrunkEllipsoid, directionToPoint, vertices, stride, center, result);\n    };\n\n    var subsampleScratch = [];\n\n    /**\n     * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n     * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n     * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n     * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n     *\n     * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n     * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n     *                    the ellipsoid used by this instance for occlusion testing.\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n     */\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function(rectangle, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('rectangle', rectangle);\n        //>>includeEnd('debug');\n\n        var positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, subsampleScratch);\n        var bs = BoundingSphere.fromPoints(positions);\n\n        // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n        // sense to try to horizon cull it.\n        if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n            return undefined;\n        }\n\n        return this.computeHorizonCullingPoint(bs.center, positions, result);\n    };\n\n    var scratchEllipsoidShrunkRadii = new Cartesian3();\n\n    function getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n        if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\n            var ellipsoidShrunkRadii = Cartesian3.fromElements(\n                ellipsoid.radii.x + minimumHeight,\n                ellipsoid.radii.y + minimumHeight,\n                ellipsoid.radii.z + minimumHeight,\n                scratchEllipsoidShrunkRadii\n            );\n            ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n        }\n        return ellipsoid;\n    }\n\n    function computeHorizonCullingPointFromPositions(ellipsoid, directionToPoint, positions, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('directionToPoint', directionToPoint);\n        Check.defined('positions', positions);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\n        var resultMagnitude = 0.0;\n\n        for (var i = 0, len = positions.length; i < len; ++i) {\n            var position = positions[i];\n            var candidateMagnitude = computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint);\n            if (candidateMagnitude < 0.0) {\n                // all points should face the same direction, but this one doesn't, so return undefined\n                return undefined;\n            }\n            resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n        }\n\n        return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n    }\n\n    var positionScratch = new Cartesian3();\n\n    function computeHorizonCullingPointFromVertices(ellipsoid, directionToPoint, vertices, stride, center, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('directionToPoint', directionToPoint);\n        Check.defined('vertices', vertices);\n        Check.typeOf.number('stride', stride);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        stride = defaultValue(stride, 3);\n        center = defaultValue(center, Cartesian3.ZERO);\n        var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\n        var resultMagnitude = 0.0;\n\n        for (var i = 0, len = vertices.length; i < len; i += stride) {\n            positionScratch.x = vertices[i] + center.x;\n            positionScratch.y = vertices[i + 1] + center.y;\n            positionScratch.z = vertices[i + 2] + center.z;\n\n            var candidateMagnitude = computeMagnitude(ellipsoid, positionScratch, scaledSpaceDirectionToPoint);\n            if (candidateMagnitude < 0.0) {\n                // all points should face the same direction, but this one doesn't, so return undefined\n                return undefined;\n            }\n            resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n        }\n\n        return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n    }\n\n    function isScaledSpacePointVisible(occludeeScaledSpacePosition, cameraPositionInScaledSpace, distanceToLimbInScaledSpaceSquared) {\n        // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n        var cv = cameraPositionInScaledSpace;\n        var vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n        var vt = Cartesian3.subtract(occludeeScaledSpacePosition, cv, scratchCartesian);\n        var vtDotVc = -Cartesian3.dot(vt, cv);\n        // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n        // in this case, set the culling plane to be on V.\n        var isOccluded = vhMagnitudeSquared < 0 ? vtDotVc > 0 : (vtDotVc > vhMagnitudeSquared &&\n                         vtDotVc * vtDotVc / Cartesian3.magnitudeSquared(vt) > vhMagnitudeSquared);\n        return !isOccluded;\n    }\n\n    var scaledSpaceScratch = new Cartesian3();\n    var directionScratch = new Cartesian3();\n\n    function computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n        var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(position, scaledSpaceScratch);\n        var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n        var magnitude = Math.sqrt(magnitudeSquared);\n        var direction = Cartesian3.divideByScalar(scaledSpacePosition, magnitude, directionScratch);\n\n        // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n        magnitudeSquared = Math.max(1.0, magnitudeSquared);\n        magnitude = Math.max(1.0, magnitude);\n\n        var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n        var sinAlpha = Cartesian3.magnitude(Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction));\n        var cosBeta = 1.0 / magnitude;\n        var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n        return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n    }\n\n    function magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result) {\n        // The horizon culling point is undefined if there were no positions from which to compute it,\n        // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n        if (resultMagnitude <= 0.0 || resultMagnitude === 1.0 / 0.0 || resultMagnitude !== resultMagnitude) {\n            return undefined;\n        }\n\n        return Cartesian3.multiplyByScalar(scaledSpaceDirectionToPoint, resultMagnitude, result);\n    }\n\n    var directionToPointScratch = new Cartesian3();\n\n    function computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n        if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n            return directionToPoint;\n        }\n\n        ellipsoid.transformPositionToScaledSpace(directionToPoint, directionToPointScratch);\n        return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n    }\nexport default EllipsoidalOccluder;\n","\n    /**\n     * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\n     *\n     * @exports TerrainQuantization\n     *\n     * @private\n     */\n    var TerrainQuantization = {\n        /**\n         * The vertices are not compressed.\n         *\n         * @type {Number}\n         * @constant\n         */\n        NONE : 0,\n\n        /**\n         * The vertices are compressed to 12 bits.\n         *\n         * @type {Number}\n         * @constant\n         */\n        BITS12 : 1\n    };\nexport default Object.freeze(TerrainQuantization);\n","import AttributeCompression from './AttributeCompression.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport CesiumMath from './Math.js';\nimport Matrix4 from './Matrix4.js';\nimport TerrainQuantization from './TerrainQuantization.js';\n\n    var cartesian3Scratch = new Cartesian3();\n    var cartesian3DimScratch = new Cartesian3();\n    var cartesian2Scratch = new Cartesian2();\n    var matrix4Scratch = new Matrix4();\n    var matrix4Scratch2 = new Matrix4();\n\n    var SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n    /**\n     * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n     * are unpacked in the vertex shader.\n     *\n     * @alias TerrainEncoding\n     * @constructor\n     *\n     * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n     * @param {Number} minimumHeight The minimum height.\n     * @param {Number} maximumHeight The maximum height.\n     * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n     * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\n     * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n     *\n     * @private\n     */\n    function TerrainEncoding(axisAlignedBoundingBox, minimumHeight, maximumHeight, fromENU, hasVertexNormals, hasWebMercatorT) {\n        var quantization = TerrainQuantization.NONE;\n        var center;\n        var toENU;\n        var matrix;\n\n        if (defined(axisAlignedBoundingBox) && defined(minimumHeight) && defined(maximumHeight) && defined(fromENU)) {\n            var minimum = axisAlignedBoundingBox.minimum;\n            var maximum = axisAlignedBoundingBox.maximum;\n\n            var dimensions = Cartesian3.subtract(maximum, minimum, cartesian3DimScratch);\n            var hDim = maximumHeight - minimumHeight;\n            var maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n\n            if (maxDim < SHIFT_LEFT_12 - 1.0) {\n                quantization = TerrainQuantization.BITS12;\n            } else {\n                quantization = TerrainQuantization.NONE;\n            }\n\n            center = axisAlignedBoundingBox.center;\n            toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n\n            var translation = Cartesian3.negate(minimum, cartesian3Scratch);\n            Matrix4.multiply(Matrix4.fromTranslation(translation, matrix4Scratch), toENU, toENU);\n\n            var scale = cartesian3Scratch;\n            scale.x = 1.0 / dimensions.x;\n            scale.y = 1.0 / dimensions.y;\n            scale.z = 1.0 / dimensions.z;\n            Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\n\n            matrix = Matrix4.clone(fromENU);\n            Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\n\n            fromENU = Matrix4.clone(fromENU, new Matrix4());\n\n            var translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\n            var scaleMatrix =  Matrix4.fromScale(dimensions, matrix4Scratch2);\n            var st = Matrix4.multiply(translationMatrix, scaleMatrix,matrix4Scratch);\n\n            Matrix4.multiply(fromENU, st, fromENU);\n            Matrix4.multiply(matrix, st, matrix);\n        }\n\n        /**\n         * How the vertices of the mesh were compressed.\n         * @type {TerrainQuantization}\n         */\n        this.quantization = quantization;\n\n        /**\n         * The minimum height of the tile including the skirts.\n         * @type {Number}\n         */\n        this.minimumHeight = minimumHeight;\n\n        /**\n         * The maximum height of the tile.\n         * @type {Number}\n         */\n        this.maximumHeight = maximumHeight;\n\n        /**\n         * The center of the tile.\n         * @type {Cartesian3}\n         */\n        this.center = center;\n\n        /**\n         * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n         * it so each component is in the [0, 1] range.\n         * @type {Matrix4}\n         */\n        this.toScaledENU = toENU;\n\n        /**\n         * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n         * @type {Matrix4}\n         */\n        this.fromScaledENU = fromENU;\n\n        /**\n         * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n         * @type {Matrix4}\n         */\n        this.matrix = matrix;\n\n        /**\n         * The terrain mesh contains normals.\n         * @type {Boolean}\n         */\n        this.hasVertexNormals = hasVertexNormals;\n\n        /**\n         * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n         * @type {Boolean}\n         */\n        this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\n    }\n\n    TerrainEncoding.prototype.encode = function(vertexBuffer, bufferIndex, position, uv, height, normalToPack, webMercatorT) {\n        var u = uv.x;\n        var v = uv.y;\n\n        if (this.quantization === TerrainQuantization.BITS12) {\n            position = Matrix4.multiplyByPoint(this.toScaledENU, position, cartesian3Scratch);\n\n            position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n            position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n            position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n\n            var hDim = this.maximumHeight - this.minimumHeight;\n            var h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n\n            Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n            var compressed0 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n            Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n            var compressed1 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n            Cartesian2.fromElements(u, v, cartesian2Scratch);\n            var compressed2 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n            vertexBuffer[bufferIndex++] = compressed0;\n            vertexBuffer[bufferIndex++] = compressed1;\n            vertexBuffer[bufferIndex++] = compressed2;\n\n            if (this.hasWebMercatorT) {\n                Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n                var compressed3 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n                vertexBuffer[bufferIndex++] = compressed3;\n            }\n        } else {\n            Cartesian3.subtract(position, this.center, cartesian3Scratch);\n\n            vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n            vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n            vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n            vertexBuffer[bufferIndex++] = height;\n            vertexBuffer[bufferIndex++] = u;\n            vertexBuffer[bufferIndex++] = v;\n\n            if (this.hasWebMercatorT) {\n                vertexBuffer[bufferIndex++] = webMercatorT;\n            }\n        }\n\n        if (this.hasVertexNormals) {\n            vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(normalToPack);\n        }\n\n        return bufferIndex;\n    };\n\n    TerrainEncoding.prototype.decodePosition = function(buffer, index, result) {\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        index *= this.getStride();\n\n        if (this.quantization === TerrainQuantization.BITS12) {\n            var xy = AttributeCompression.decompressTextureCoordinates(buffer[index], cartesian2Scratch);\n            result.x = xy.x;\n            result.y = xy.y;\n\n            var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\n            result.z = zh.x;\n\n            return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n        }\n\n        result.x = buffer[index];\n        result.y = buffer[index + 1];\n        result.z = buffer[index + 2];\n        return Cartesian3.add(result, this.center, result);\n    };\n\n    TerrainEncoding.prototype.decodeTextureCoordinates = function(buffer, index, result) {\n        if (!defined(result)) {\n            result = new Cartesian2();\n        }\n\n        index *= this.getStride();\n\n        if (this.quantization === TerrainQuantization.BITS12) {\n            return AttributeCompression.decompressTextureCoordinates(buffer[index + 2], result);\n        }\n\n        return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n    };\n\n    TerrainEncoding.prototype.decodeHeight = function(buffer, index) {\n        index *= this.getStride();\n\n        if (this.quantization === TerrainQuantization.BITS12) {\n            var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\n            return zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight;\n        }\n\n        return buffer[index + 3];\n    };\n\n    TerrainEncoding.prototype.decodeWebMercatorT = function(buffer, index) {\n        index *= this.getStride();\n\n        if (this.quantization === TerrainQuantization.BITS12) {\n            return AttributeCompression.decompressTextureCoordinates(buffer[index + 3], cartesian2Scratch).x;\n        }\n\n        return buffer[index + 6];\n    };\n\n    TerrainEncoding.prototype.getOctEncodedNormal = function(buffer, index, result) {\n        var stride = this.getStride();\n        index = (index + 1) * stride - 1;\n\n        var temp = buffer[index] / 256.0;\n        var x = Math.floor(temp);\n        var y = (temp - x) * 256.0;\n\n        return Cartesian2.fromElements(x, y, result);\n    };\n\n    TerrainEncoding.prototype.getStride = function() {\n        var vertexStride;\n\n        switch (this.quantization) {\n            case TerrainQuantization.BITS12:\n                vertexStride = 3;\n                break;\n            default:\n                vertexStride = 6;\n        }\n\n        if (this.hasWebMercatorT) {\n            ++vertexStride;\n        }\n\n        if (this.hasVertexNormals) {\n            ++vertexStride;\n        }\n\n        return vertexStride;\n    };\n\n    var attributesNone = {\n        position3DAndHeight : 0,\n        textureCoordAndEncodedNormals : 1\n    };\n    var attributes = {\n        compressed0 : 0,\n        compressed1 : 1\n    };\n\n    TerrainEncoding.prototype.getAttributes = function(buffer) {\n        var datatype = ComponentDatatype.FLOAT;\n        var sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n        var stride;\n\n        if (this.quantization === TerrainQuantization.NONE) {\n            var position3DAndHeightLength = 4;\n            var numTexCoordComponents = 2;\n\n            if (this.hasWebMercatorT) {\n                ++numTexCoordComponents;\n            }\n\n            if (this.hasVertexNormals) {\n                ++numTexCoordComponents;\n            }\n\n            stride = (position3DAndHeightLength + numTexCoordComponents) * sizeInBytes;\n\n            return [{\n                index : attributesNone.position3DAndHeight,\n                vertexBuffer : buffer,\n                componentDatatype : datatype,\n                componentsPerAttribute : position3DAndHeightLength,\n                offsetInBytes : 0,\n                strideInBytes : stride\n            }, {\n                index : attributesNone.textureCoordAndEncodedNormals,\n                vertexBuffer : buffer,\n                componentDatatype : datatype,\n                componentsPerAttribute : numTexCoordComponents,\n                offsetInBytes : position3DAndHeightLength * sizeInBytes,\n                strideInBytes : stride\n            }];\n        }\n\n        var numCompressed0 = 3;\n        var numCompressed1 = 0;\n\n        if (this.hasWebMercatorT || this.hasVertexNormals) {\n            ++numCompressed0;\n        }\n\n        if (this.hasWebMercatorT && this.hasVertexNormals) {\n            ++numCompressed1;\n\n            stride = (numCompressed0 + numCompressed1) * sizeInBytes;\n\n            return [{\n                index : attributes.compressed0,\n                vertexBuffer : buffer,\n                componentDatatype : datatype,\n                componentsPerAttribute : numCompressed0,\n                offsetInBytes : 0,\n                strideInBytes : stride\n            }, {\n                index : attributes.compressed1,\n                vertexBuffer : buffer,\n                componentDatatype : datatype,\n                componentsPerAttribute : numCompressed1,\n                offsetInBytes : numCompressed0 * sizeInBytes,\n                strideInBytes : stride\n            }];\n        }\n        return [{\n            index : attributes.compressed0,\n            vertexBuffer : buffer,\n            componentDatatype : datatype,\n            componentsPerAttribute : numCompressed0\n        }];\n    };\n\n    TerrainEncoding.prototype.getAttributeLocations = function() {\n        if (this.quantization === TerrainQuantization.NONE) {\n            return attributesNone;\n        }\n        return attributes;\n    };\n\n    TerrainEncoding.clone = function(encoding, result) {\n        if (!defined(result)) {\n            result = new TerrainEncoding();\n        }\n\n        result.quantization = encoding.quantization;\n        result.minimumHeight = encoding.minimumHeight;\n        result.maximumHeight = encoding.maximumHeight;\n        result.center = Cartesian3.clone(encoding.center);\n        result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n        result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n        result.matrix = Matrix4.clone(encoding.matrix);\n        result.hasVertexNormals = encoding.hasVertexNormals;\n        result.hasWebMercatorT = encoding.hasWebMercatorT;\n        return result;\n    };\nexport default TerrainEncoding;\n"],"names":["Check","Cartesian3","defined","Ellipsoid","Rectangle","BoundingSphere","defaultValue","Cartesian2","Matrix4","TerrainQuantization","CesiumMath","AttributeCompression","ComponentDatatype"],"mappings":"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"}